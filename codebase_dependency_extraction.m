function [nodes, dup_list, cols, unique_places] = codebase_dependency_extraction(codebase_structure)
% Goes through the matrix generated by make index and gets the dependency
% data.
% Args:
%      codebase_structure (structure): structure of interdependencies.
% Example: [nodes, dup_list, cols, unique_places] = codebase_dependency_extraction(codebase_structure)

codebase_tree = codebase_structure.tree;
lp = length(codebase_tree);
% Going through the list and making an initial set of names, locations, and
% number of interconnections
names_cell = {};
ck = 1;
for sa = 1:lp
    %     if sa == 1
    if isempty(codebase_tree(sa).val) || isempty(codebase_tree(sa).dir_path)
        continue
    else
        nodes(ck).name = codebase_tree(sa).val;
        % conditioning the filenames to remove -, spaces and empty entries
        nodes(ck).name_cell = filename_conditioning(cellstr(nodes(sa).name));
        pth_tmp = cellstr(codebase_tree(sa).dir_path);
        nodes(ck).path = pth_tmp;
        if strcmp(pth_tmp{1}(end),filesep)
            nodes(ck).place = pth_tmp{1}(1:end-1);
        else
            nodes(ck).place = pth_tmp{1};
        end %if
        nodes(ck).place = regexprep(nodes(ck).place, codebase_structure.repo_info.location, 'Root');
        nodes(ck).place = regexprep(nodes(ck).place,'\\','\/');
        nodes(ck).place = regexprep(nodes(ck).place,'\/','@');
        nodes(ck).modified_date = cellstr(codebase_tree(sa).last_modified_date);
        nodes(ck).modified_by = cellstr(codebase_tree(sa).last_modified_by);
        nodes(ck).description = cellstr(regexprep(codebase_tree(sa).description,'&','and'));
        nodes(ck).containing_m_file = codebase_tree(sa).containing_m_file;
        nodes(ck).children = filename_conditioning(codebase_tree(sa).funcs_called);
        % number of connections
        nodes(ck).conectivity = length(nodes(ck).children);
        nodes(ck).parents = {};
        nodes(ck).children_loc = {};
        nodes(ck).children_num = [];
        nodes(ck).parents_loc = {};
        nodes(ck).parents_num = [];
        nodes(ck).number = ck;
        names_cell{ck} = nodes(sa).name_cell;
        ck = ck +1;
    end %if
end %for

% Identifying and removing duplicates.
[dup_list, unique_duplicated_names, all_duplicates] = find_duplicates(nodes);
nodes = remove_duplicates(nodes, unique_duplicated_names, all_duplicates);

% Going through the list again to work out the routine by routine
% dependencies
for sa = 1:length(nodes)
    ok_pnts = zeros(length(nodes(sa).children),1);
    for hea = 1:length(nodes(sa).children)
        for ns = 1:length(nodes)
            if strcmp(nodes(ns).name_cell, nodes(sa).children{hea})
                nodes(ns).parents(end+1) = nodes(sa).name_cell;
                nodes(ns).conectivity = nodes(ns).conectivity +1;
                nodes(ns).parents_loc{end+1} = nodes(sa).place;
                nodes(ns).parents_num(end+1) = nodes(sa).number;
                if ~isempty(nodes(ns).place)
                    nodes(sa).children_loc{hea} = nodes(ns).place;
                    nodes(sa).children_num(hea) = nodes(ns).number;
                else
                    % Mark children with missing places for removal from the
                    % list.
                    % Writing 0 into the location as otherwise if it is the
                    % last on in the list, the list is 1 element shorter which
                    % breaks the comparison code later.
                    nodes(sa).children_loc{hea} = 0;
                    nodes(sa).children_num(hea) = 0;
                    ok_pnts(hea) = 1;
                end %if
            end %if
        end %for
        try
            nodes(sa).children_loc{hea};
        catch
            nodes(sa).children_loc{hea} = 0;
            nodes(sa).children_num(hea) = 0;
            ok_pnts(hea) = 1;
        end %try
    end %for
    nodes(sa).children_loc(ok_pnts == 1) = [];
    nodes(sa).children_num(ok_pnts == 1) = [];
    nodes(sa).children(ok_pnts == 1) = [];
end %for

%% Generating what colour each node has
node_places = cell(1,1);
for nwa = 1:length(nodes)
    node_places{nwa} = nodes(nwa).place;
end %for
unique_places = unique(node_places);
n_places = length(unique_places);
% generate random numbers in the range 40 to 238 so as to keep the colours
% away from full saturation and interfere with things like the visibility
% of hyperlinks.
cols = {};
while length(cols) <n_places
 cols = generate_html_colour_codes(n_places);
end %while
for kh = 1:length(nodes)
    sc = strmatch(nodes(kh).place,unique_places,'exact');
    if ~isempty(strfind(nodes(kh).place,'deprecated'))
        nodes(kh).html_colour = '#FF0000';
        nodes(kh).colour = '#FF0000';
        cols(sc,:) = 'FF0000';
    else
        nodes(kh).html_colour = ['#',cols(sc,:)];
        nodes(kh).colour = ['#',cols(sc,:)];
    end %if
end %for
cols = cellstr(cols);